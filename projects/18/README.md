## Очереди.

### Материалы:
- [rabbitmq-tutorials](https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/php)
- [GitHub - pgq/pgq: Generic Queue for PostgreSQL](https://github.com/pgq/pgq)
- [RabbitMQ против Kafka: два разных подхода к обмену сообщениями](https://habr.com/ru/company/itsumma/blog/416629/)
- [GitHub - php-amqplib/php-amqplib: The most widely used PHP client for RabbitMQ](https://github.com/php-amqplib/php-amqplib)
- [GitHub - arnaud-lb/php-rdkafka: Production-ready, stable Kafka client for PHP](https://github.com/arnaud-lb/php-rdkafka)
- [Второй PHP-митап ульяновского сообщества про Go, Consistent Hash в RabbitMQ и не только](https://youtu.be/H6FX1KZwcnk)

#### Описание/Пошаговая инструкция выполнения задания:
Пишем приложение обработки отложенных запросов.
1. Создать простое веб-приложение, принимающее `POST` запрос из формы от пользователя. Например, запрос на генерацию банковской выписки за указанные даты.
2. Обычно такие запросы (в реальных системах) работают довольно долго, поэтому пользователя надо оповестить о том, что запрос принят в обработку.
3. Форма должна подразумевать отправку оповещения по результатам работы.
4. Передать тело запроса в очередь.
5. Написать скрипт, который будет читать сообщения из очереди и выводить информацию о них в консоль.
6. Реализация оповещения.
7. Сгенерированный ответ отправить через `email` или `telegram`.
8. Приложить инструкцию по запуску системы.

#### Критерии оценки:
- Работоспособность решения (5 баллов);
- Чистота кода (3 балла);
- Инструкции по развёртыванию системы (2 балла).

## Результат:
- `Docker`.
- `Supervisor`.
- `Clean architecture`.
- `CQRS`.
- `Symfony Messenger`.
- `Symfony Lock`.
- `RabbitMQ`.

### Запуск: основные команды
1. `make init` - сообираются контейнеры, запускается сервис.
2.
    1. `make consume` - запуск консьюмеров в фоновом режиме.
    2. `make consume-in-console` - для выполнения пункта **5** задачи.
3. `make tests` - команда запускает тесты.

P.S. Реализовал с немного другой логикой чем в задаче.  
`workflow`:
- С фронта летит `POST` запрос на генерацию банковской выписки.
```shell
curl --location 'http://application.local:8081/bank/statement/generate' \
--header 'Content-Type: application/json' \
--data-raw '{
"email": "lanposts@gmail.com",
"startDate": "2023-06-01",
"endDate": "2023-06-03"
}'
```
- Создается `Command` и отправляется в транспорт, через `middleware` валидируется, если `OK` - попадает в `RMQ`.
- В отдельном контейнере крутится `consumer` через `supervisor` на 2 инстанса.
- `Handler` принимает из `RMQ` сообщение, эмулирует проверку БД на существование сгенерированной за эти даты банковской выписки. Если она отсутствует - запускает генерацию выписки через вызов консольной команды. По завершению генерации создается событие `created` которое отправляется обратно в `RMQ`.
- На `created` подписан обработчик, который отправляет письмо на `email` указанный в `POST` запросе. С содержимым о готовности выписки.
